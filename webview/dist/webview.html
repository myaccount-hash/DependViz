<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Security-Policy" content="default-src 'none'; img-src {{cspSource}} https: data:; script-src {{cspSource}} https://esm.sh 'nonce-{{nonce}}'; style-src {{cspSource}} 'unsafe-inline'; connect-src {{cspSource}};">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1e1e1e;
            color: #cccccc;
            overflow: hidden;
        }
        #graph-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
    </style>
</head>
<body>
    <div id="graph-container"></div>
    <script nonce="{{nonce}}" type="module">
        // @ts-nocheck
        Promise.all([
            import("{{fgUri}}"),
            import("{{fg3dUri}}"),
            import('https://esm.sh/three/examples/jsm/renderers/CSS2DRenderer.js')
        ]).then(([fg2dModule, fg3dModule, css2dModule]) => {
            window.ForceGraph = fg2dModule.default || fg2dModule.ForceGraph || fg2dModule;
            window.ForceGraph3D = fg3dModule.default || fg3dModule.ForceGraph3D || fg3dModule;
            window.CSS2DRenderer = css2dModule.CSS2DRenderer;
            window.CSS2DObject = css2dModule.CSS2DObject;

            const DEFAULT_CONTROLS = {{defaultControls}};
            const COLORS = {{colors}};
            const DEBUG = {{debug}};

            (function(DEFAULT_CONTROLS, COLORS, DEBUG) {
const vscode = typeof acquireVsCodeApi === 'function' ? acquireVsCodeApi() : null;


class GraphState {
  constructor() {
    this.data = { nodes: [], links: [] };
    this.controls = DEFAULT_CONTROLS;
    this.ui = {
      highlightLinks: new Set(),
      stackTraceLinks: new Set(),
      focusedNode: null,
      isUserInteracting: false
    };
    this.rotation = {
      frame: null,
      startTime: null,
      startAngle: null,
      timeout: null
    };
    this._graph = null;
    this._labelRenderer = null;
    this.nodeRules = [
      (node, ctx) => {
        const map = {
          Class: ctx.controls.colorClass,
          AbstractClass: ctx.controls.colorAbstractClass,
          Interface: ctx.controls.colorInterface,
          Unknown: ctx.controls.colorUnknown
        };
        return map[node.type] ? { color: map[node.type] } : null;
      },
      (node, ctx) => ctx.controls.nodeSizeByLoc && node.linesOfCode > 0 && {
        sizeMultiplier: Math.max(1, Math.pow(node.linesOfCode, 0.7))
      }
    ];
    this.linkRules = [
      (link, ctx) => ctx.ui.stackTraceLinks.has(link) && {
        color: COLORS.STACK_TRACE_LINK,
        widthMultiplier: 2.5,
        particles: 5
      },
      (link, ctx) => ctx.ui.highlightLinks.has(link) && {
        widthMultiplier: 2,
        particles: 4
      },
      (link, ctx) => {
        const map = {
          ObjectCreate: ctx.controls.colorObjectCreate,
          Extends: ctx.controls.colorExtends,
          Implements: ctx.controls.colorImplements,
          TypeUse: ctx.controls.colorTypeUse,
          MethodCall: ctx.controls.colorMethodCall
        };
        return map[link.type] ? { color: map[link.type] } : null;
      }
    ];
  }

  get graph() { return this._graph; }
  get labelRenderer() { return this._labelRenderer; }

  setGraph(graph) { this._graph = graph; }
  setLabelRenderer(renderer) { this._labelRenderer = renderer; }

  getBackgroundColor() {
    const style = getComputedStyle(document.body);
    const bgColor = style.getPropertyValue('--vscode-editor-background').trim();
    return bgColor || COLORS.BACKGROUND_DARK;
  }

  updateData(data) {
    this.data = { nodes: [...(data.nodes || [])], links: [...(data.links || [])] };
  }

  updateControls(controls) {
    this.controls = { ...this.controls, ...controls };
  }

  _getNodeFilePath(node) {
    return node.filePath || node.file;
  }

  _normalizePath(path) {
    if (!path) return '';
    let normalized = path.replace(/\\/g, '/');
    normalized = normalized.replace(/\/+$/, '');
    const parts = normalized.split('/').filter(p => p && p !== '.');
    const result = [];
    for (const part of parts) {
      if (part === '..') {
        if (result.length > 0 && result[result.length - 1] !== '..') {
          result.pop();
        } else {
          result.push(part);
        }
      } else {
        result.push(part);
      }
    }
    return result.join('/');
  }

  _pathsMatch(path1, path2) {
    if (!path1 || !path2) return false;
    const norm1 = this._normalizePath(path1);
    const norm2 = this._normalizePath(path2);
    if (norm1 === norm2) return true;
    const parts1 = norm1.split('/').filter(Boolean);
    const parts2 = norm2.split('/').filter(Boolean);
    if (parts1.length === 0 || parts2.length === 0) return false;
    const minLen = Math.min(parts1.length, parts2.length);
    if (minLen < 2) return false;
    for (let i = 1; i <= minLen; i++) {
      const suffix1 = parts1.slice(-i).join('/');
      const suffix2 = parts2.slice(-i).join('/');
      if (suffix1 === suffix2) return true;
    }
    return false;
  }

  _computeNodeLabel(node) {
    if (!node.name) return node.id || '';
    if (!this.controls.shortNames) return node.name;
    const lastDot = node.name.lastIndexOf('.');
    return lastDot !== -1 ? node.name.substring(lastDot + 1) : node.name;
  }

  _applyRules(item, rules, defaults) {
    const result = { ...defaults };
    for (const rule of rules) {
      const ruleResult = rule(item, this);
      if (ruleResult) Object.assign(result, ruleResult);
    }
    return result;
  }

  getNodeVisualProps(node) {
    const props = this._applyRules(node, this.nodeRules, {
      color: COLORS.NODE_DEFAULT,
      sizeMultiplier: 1,
      label: this._computeNodeLabel(node),
      opacity: this.controls.nodeOpacity
    });

    // Apply focus dimming
    if (this.ui.focusedNode) {
      const isFocused = node.id === this.ui.focusedNode.id;
      const isNeighbor = this.ui.focusedNode.neighbors &&
                         this.ui.focusedNode.neighbors.some(n => n.id === node.id);

      if (!isFocused && !isNeighbor) {
        props.opacity = (props.opacity || 1) * 0.2;
      }
    }

    return { ...props, size: (props.sizeMultiplier || 1) * this.controls.nodeSize };
  }

  getLinkVisualProps(link) {
    const props = this._applyRules(link, this.linkRules, {
      color: COLORS.EDGE_DEFAULT,
      widthMultiplier: 1,
      particles: 0,
      opacity: this.controls.edgeOpacity,
      arrowSize: this.controls.arrowSize
    });

    // Apply focus dimming and highlighting
    if (this.ui.focusedNode) {
      const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
      const targetId = typeof link.target === 'object' ? link.target.id : link.target;
      const focusedId = this.ui.focusedNode.id;

      const isConnectedToFocus = sourceId === focusedId || targetId === focusedId;

      if (isConnectedToFocus) {
        // Add particles to focused edges
        props.particles = 3;
        props.widthMultiplier = (props.widthMultiplier || 1) * 1.5;
      } else {
        props.opacity = (props.opacity || 1) * 0.1;
      }
    }

    return { ...props, width: (props.widthMultiplier || 1) * this.controls.linkWidth };
  }

  initGraph() {
    if (this.controls.is3DMode) {
      return initGraph3D(this);
    } else {
      return initGraph2D(this);
    }
  }

  toggleMode() {
    // 設定値は外部（GraphViewProvider）で更新されるので、ここではグラフをリセットするだけ
    this.cancelRotation();
    this._graph = null;
    this._labelRenderer = null;
  }

  cancelRotation() {
    if (this.rotation.frame) {
      cancelAnimationFrame(this.rotation.frame);
      this.rotation.frame = null;
    }
    clearTimeout(this.rotation.timeout);
  }
}


function applyFilter(nodes, links) {
  const controls = state.controls;

  let filteredNodes = nodes.filter(node => {
    if (!controls[`show${node.type}`]) return false;
    if (controls.hideIsolatedNodes && (!node.neighbors || node.neighbors.length === 0)) return false;
    if (controls.search && !matchesSearchQuery(node, controls.search)) return false;
    return true;
  });

  if (state.ui.focusedNode && (controls.enableForwardSlice || controls.enableBackwardSlice)) {
    const sliceNodes = new Set();
    sliceNodes.add(state.ui.focusedNode.id);

    if (controls.enableForwardSlice) {
      traverseSlice(state.ui.focusedNode, 'forward', controls.sliceDepth, sliceNodes, nodes, links);
    }
    if (controls.enableBackwardSlice) {
      traverseSlice(state.ui.focusedNode, 'backward', controls.sliceDepth, sliceNodes, nodes, links);
    }

    filteredNodes = filteredNodes.filter(node => sliceNodes.has(node.id));
  }

  const nodeIds = new Set(filteredNodes.map(n => n.id));
  const filteredLinks = links.filter(link => {
    if (!controls[`show${link.type}`]) return false;
    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
    return nodeIds.has(sourceId) && nodeIds.has(targetId);
  });

  return { nodes: filteredNodes, links: filteredLinks };
}

function traverseSlice(node, direction, depth, visited, allNodes, allLinks) {
  if (depth <= 0) return;

  const relevantLinks = allLinks.filter(link => {
    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
    return direction === 'forward' ? sourceId === node.id : targetId === node.id;
  });

  relevantLinks.forEach(link => {
    const nextNodeId = direction === 'forward'
      ? (typeof link.target === 'object' ? link.target.id : link.target)
      : (typeof link.source === 'object' ? link.source.id : link.source);

    if (!visited.has(nextNodeId)) {
      visited.add(nextNodeId);
      const nextNode = allNodes.find(n => n.id === nextNodeId);
      if (nextNode) {
        traverseSlice(nextNode, direction, depth - 1, visited, allNodes, allLinks);
      }
    }
  });
}

function matchesSearchQuery(node, query) {
  if (!query) return true;
  const q = query.toLowerCase();

  if (q.includes(':')) {
    const hasAnd = q.includes(' and ');
    const hasOr = q.includes(' or ');
    const parts = q.split(/\s+and\s+|\s+or\s+/).map(s => s.trim());

    const results = parts.map(subQ => {
      if (subQ.startsWith('not ')) {
        return !evaluateFieldQuery(node, subQ.substring(4));
      }
      return evaluateFieldQuery(node, subQ);
    });

    if (hasAnd && !hasOr) return results.every(Boolean);
    if (hasOr && !hasAnd) return results.some(Boolean);
    if (hasAnd && hasOr) return results.every(Boolean);
    return results[0];
  }

  return (node.name && node.name.toLowerCase().includes(q)) ||
         (node.id && node.id.toLowerCase().includes(q));
}

function evaluateFieldQuery(node, query) {
  const match = query.match(/^(\w+):(.+)$/);
  if (!match) return false;

  const [, field, rawValue] = match;
  const isRegex = rawValue.startsWith('/') && rawValue.endsWith('/');
  const searchValue = isRegex ? rawValue.slice(1, -1) : rawValue;

  let nodeValue = '';
  if (field === 'name') nodeValue = node.name || '';
  else if (field === 'type') nodeValue = node.type || '';
  else if (field === 'path') nodeValue = node.filePath || node.file || '';

  if (isRegex) {
    try {
      return new RegExp(searchValue, 'i').test(nodeValue);
    } catch (e) {
      return false;
    }
  }

  return nodeValue.toLowerCase().includes(searchValue.toLowerCase());
}


// ラベル表示の基底クラス
class LabelRenderer {
  constructor(state) {
    this.state = state;
  }

  // サブクラスでオーバーライドするメソッド
  apply(graph, getNodeProps) {
    throw new Error('apply() must be implemented by subclass');
  }

  clear(graph) {
    throw new Error('clear() must be implemented by subclass');
  }

  getFontSize() {
    return this.state.controls.textSize || 12;
  }

  getLabel(node, props) {
    return props?.label || node.name || node.id;
  }
}

// 2D用のCanvasベースのラベルレンダラー
class Canvas2DLabelRenderer extends LabelRenderer {
  apply(graph, getNodeProps) {
    graph
      .nodeCanvasObject((node, ctx, globalScale) => {
        const props = getNodeProps(node);
        if (!props) return;
        const label = this.getLabel(node, props);
        const fontSize = this.getFontSize();
        ctx.font = `${fontSize}px Sans-Serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = applyOpacityToColor('#ffffff', props.opacity);
        ctx.fillText(label, node.x, node.y);
      })
      .nodeCanvasObjectMode(() => 'after');
  }

  clear(graph) {
    graph.nodeCanvasObjectMode(() => null);
  }
}

// 3D用のCSS2DObjectベースのラベルレンダラー
class CSS3DLabelRenderer extends LabelRenderer {
  getFontSize() {
    return this.state.controls.nameFontSize || 12;
  }

  apply(graph, getNodeProps) {
    if (typeof window.CSS2DObject === 'undefined') {
      console.warn('[LabelRenderer] CSS2DObject not available');
      return;
    }

    graph.nodeThreeObject(node => {
      const props = getNodeProps(node);
      const div = document.createElement('div');
      div.textContent = this.getLabel(node, props);
      Object.assign(div.style, {
        fontSize: `${this.getFontSize()}px`,
        fontFamily: 'sans-serif',
        padding: '2px 4px',
        borderRadius: '2px',
        pointerEvents: 'none',
        color: props.color
      });
      const label = new window.CSS2DObject(div);
      label.position.set(0, -8, 0);
      return label;
    }).nodeThreeObjectExtend(true);
  }

  clear(graph) {
    graph.nodeThreeObject(null).nodeThreeObjectExtend(false);
  }
}


// 2D専用レンダラー

function updateGraph2D(state, options = {}) {
  const { reheatSimulation = false } = options;

  if (!state.graph) {
    console.error('[DependViz] Graph not initialized');
    return;
  }

  state.graph.backgroundColor(state.getBackgroundColor());

  const nodes = state.data.nodes || [];
  const links = state.data.links || [];

  const { nodeVisualCache, linkVisualCache } = buildVisualCache(nodes, links, state);
  const getNodeProps = node => nodeVisualCache.get(node);
  const getLinkProps = link => linkVisualCache.get(link);

  const filteredData = applyFilter(nodes, links);
  state.graph.graphData(filteredData);

  // 2Dモード専用: nodeCanvasObjectを使用してテキストを描画
  const labelRenderer = new Canvas2DLabelRenderer(state);
  if (state.controls.showNames) {
    labelRenderer.apply(state.graph, getNodeProps);
  } else {
    labelRenderer.clear(state.graph);
  }

  // 共通設定
  state.graph
    .nodeLabel(node => {
      const props = getNodeProps(node);
      return props ? props.label : node.name || node.id;
    })
    .nodeColor(node => {
      const props = getNodeProps(node);
      const color = props ? props.color : COLORS.NODE_DEFAULT;
      return applyOpacityToColor(color, props?.opacity);
    })
    .nodeVal(node => {
      const props = getNodeProps(node);
      return props ? props.size : state.controls.nodeSize;
    })
    .linkColor(link => {
      const props = getLinkProps(link);
      const color = props ? props.color : COLORS.EDGE_DEFAULT;
      return applyOpacityToColor(color, props?.opacity);
    })
    .linkWidth(link => {
      const props = getLinkProps(link);
      return props ? props.width : state.controls.linkWidth;
    })
    .linkDirectionalArrowLength(state.controls.arrowSize)
    .linkDirectionalParticles(link => {
      const props = getLinkProps(link);
      return props ? (props.particles || 0) : 0;
    })
    .linkDirectionalParticleWidth(2);

  const linkForce = state.graph.d3Force('link');
  if (linkForce) linkForce.distance(state.controls.linkDistance);

  if (reheatSimulation && state.graph?.d3ReheatSimulation) {
    setTimeout(() => state.graph.d3ReheatSimulation(), 100);
  }
}

function updateVisuals2D(state) {
  if (!state.graph) return;

  const nodes = state.data.nodes || [];
  const links = state.data.links || [];

  const { nodeVisualCache, linkVisualCache } = buildVisualCache(nodes, links, state);
  const getNodeProps = node => nodeVisualCache.get(node);
  const getLinkProps = link => linkVisualCache.get(link);

  // 2Dモード専用: Canvas描画
  const labelRenderer = new Canvas2DLabelRenderer(state);
  if (state.controls.showNames) {
    labelRenderer.apply(state.graph, getNodeProps);
  } else {
    labelRenderer.clear(state.graph);
  }

  state.graph
    .nodeColor(node => {
      const props = getNodeProps(node);
      const color = props ? props.color : COLORS.NODE_DEFAULT;
      return applyOpacityToColor(color, props?.opacity);
    })
    .linkColor(link => {
      const props = getLinkProps(link);
      const color = props ? props.color : COLORS.EDGE_DEFAULT;
      return applyOpacityToColor(color, props?.opacity);
    })
    .linkDirectionalParticles(link => {
      const props = getLinkProps(link);
      return props ? (props.particles || 0) : 0;
    });
}

function focusNode2D(state, node) {
  if (state.graph && node.x !== undefined && node.y !== undefined) {
    state.graph.centerAt(node.x, node.y, 1000);
  }
}

function initGraph2D(state) {
  const container = document.getElementById('graph-container');
  if (!container) {
    console.error('[DependViz] Container not found!');
    return false;
  }

  if (typeof ForceGraph === 'undefined') {
    console.error('[DependViz] ForceGraph is undefined!');
    return false;
  }

  try {
    const g = ForceGraph()(container)
      .backgroundColor(state.getBackgroundColor())
      .linkDirectionalArrowLength(5)
      .linkDirectionalArrowRelPos(1)
      .onNodeClick(node => {
        if (!node || !vscode) return;
        const filePath = state._getNodeFilePath(node);
        if (filePath) {
          vscode.postMessage({
            type: 'focusNode',
            node: {
              id: node.id,
              filePath: filePath,
              name: node.name
            }
          });
        }
      });

    state.setGraph(g);
    return true;
  } catch (error) {
    console.error('[DependViz] Error initializing 2D graph:', error);
    return false;
  }
}


// 3D専用レンダラー（mainブランチベース）

function updateGraph3D(state, options = {}) {
  const { reheatSimulation = false } = options;

  if (!state.graph) {
    console.error('[DependViz] Graph not initialized');
    return;
  }

  state.graph.backgroundColor(state.getBackgroundColor());

  const nodes = state.data.nodes || [];
  const links = state.data.links || [];

  const { nodeVisualCache, linkVisualCache } = buildVisualCache(nodes, links, state);
  const getNodeProps = node => nodeVisualCache.get(node);
  const getLinkProps = link => linkVisualCache.get(link);

  const filteredData = applyFilter(nodes, links);
  state.graph.graphData(filteredData);

  // 3Dモード: nodeThreeObjectでCSS2DObjectを使用
  const labelRenderer = new CSS3DLabelRenderer(state);
  if (state.controls.showNames) {
    labelRenderer.apply(state.graph, getNodeProps);
  } else {
    labelRenderer.clear(state.graph);
  }

  state.graph
    .nodeLabel(node => {
      const props = getNodeProps(node);
      return props ? props.label : node.name || node.id;
    })
    .nodeColor(node => {
      const props = getNodeProps(node);
      const color = props ? props.color : COLORS.NODE_DEFAULT;
      return applyOpacityToColor(color, props?.opacity);
    })
    .nodeVal(node => {
      const props = getNodeProps(node);
      return props ? props.size : state.controls.nodeSize;
    })
    .linkColor(link => {
      const props = getLinkProps(link);
      const color = props ? props.color : COLORS.EDGE_DEFAULT;
      return applyOpacityToColor(color, props?.opacity);
    })
    .linkWidth(link => {
      const props = getLinkProps(link);
      return props ? props.width : state.controls.linkWidth;
    })
    .linkDirectionalArrowLength(state.controls.arrowSize)
    .linkDirectionalParticles(link => {
      const props = getLinkProps(link);
      return props ? (props.particles || 0) : 0;
    })
    .linkDirectionalParticleWidth(2);

  const linkForce = state.graph.d3Force('link');
  if (linkForce) linkForce.distance(state.controls.linkDistance);

  // 2D風のレイアウト: Z軸方向の力を弱める
  const chargeForce = state.graph.d3Force('charge');
  if (chargeForce) chargeForce.strength(-120);

  // Z軸を平面に保つ力を追加（カスタムforce）
  state.graph.d3Force('z', () => {
    let nodes;
    const strength = 0.1;
    const z = 0;

    function force(alpha) {
      if (!nodes) return;
      for (let i = 0, n = nodes.length; i < n; ++i) {
        const node = nodes[i];
        if (node.z !== undefined) {
          node.vz = node.vz || 0;
          node.vz += (z - node.z) * strength * alpha;
        }
      }
    }

    force.initialize = function(_) {
      nodes = _;
    };

    return force;
  });

  if (reheatSimulation && state.graph?.d3ReheatSimulation) {
    setTimeout(() => state.graph.d3ReheatSimulation(), 100);
  }

  updateAutoRotation(state);
}

function updateVisuals3D(state) {
  if (!state.graph) return;

  const nodes = state.data.nodes || [];
  const links = state.data.links || [];

  const { nodeVisualCache, linkVisualCache } = buildVisualCache(nodes, links, state);
  const getNodeProps = node => nodeVisualCache.get(node);
  const getLinkProps = link => linkVisualCache.get(link);

  // nodeThreeObjectの更新
  const labelRenderer = new CSS3DLabelRenderer(state);
  if (state.controls.showNames) {
    labelRenderer.apply(state.graph, getNodeProps);
  } else {
    labelRenderer.clear(state.graph);
  }

  state.graph
    .nodeColor(node => {
      const props = getNodeProps(node);
      const color = props ? props.color : COLORS.NODE_DEFAULT;
      return applyOpacityToColor(color, props?.opacity);
    })
    .linkColor(link => {
      const props = getLinkProps(link);
      const color = props ? props.color : COLORS.EDGE_DEFAULT;
      return applyOpacityToColor(color, props?.opacity);
    })
    .linkDirectionalParticles(link => {
      const props = getLinkProps(link);
      return props ? (props.particles || 0) : 0;
    });
}

function focusNode3D(state, node) {
  if (!state.graph || !node) return;

  if (node.x === undefined || node.y === undefined || node.z === undefined) {
    setTimeout(() => focusNode3D(state, node), 100);
    return;
  }

  // 現在のカメラ位置を取得
  const currentCameraPos = state.graph.cameraPosition();

  // 現在のカメラと注目点との距離を計算
  const currentDistance = currentCameraPos
    ? Math.hypot(
        currentCameraPos.x - (state.ui.focusedNode?.x || 0),
        currentCameraPos.y - (state.ui.focusedNode?.y || 0),
        currentCameraPos.z - (state.ui.focusedNode?.z || 0)
      )
    : state.controls.focusDistance;

  // その距離を保持して新しいノードにフォーカス
  const nodeDistance = Math.hypot(node.x, node.y, node.z);
  const cameraPos = nodeDistance > 0
    ? {
      x: node.x * (1 + currentDistance / nodeDistance),
      y: node.y * (1 + currentDistance / nodeDistance),
      z: node.z * (1 + currentDistance / nodeDistance)
    }
    : { x: currentDistance, y: 0, z: 0 };

  state.graph.cameraPosition(cameraPos, node, DEBUG.AUTO_ROTATE_DELAY);
  setTimeout(() => updateAutoRotation(state), DEBUG.AUTO_ROTATE_DELAY);
}

function updateAutoRotation(state) {
  state.cancelRotation();
  if (!state.graph) return;

  if (state.controls.autoRotate && !state.ui.isUserInteracting) {
    const pos = state.graph.cameraPosition();
    state.rotation.startAngle = Math.atan2(pos.x, pos.z);
    state.rotation.startTime = Date.now();

    const rotate = () => {
      const camera = state.graph.camera();
      const controls = state.graph.controls();
      if (camera && controls) {
        if (state.ui.focusedNode) {
          controls.target.set(
            state.ui.focusedNode.x || 0,
            state.ui.focusedNode.y || 0,
            state.ui.focusedNode.z || 0
          );
        }
        const elapsed = (Date.now() - state.rotation.startTime) * 0.001;
        const angle = state.rotation.startAngle + elapsed * state.controls.rotateSpeed;
        const distance = Math.sqrt(camera.position.x ** 2 + camera.position.z ** 2);
        camera.position.x = distance * Math.sin(angle);
        camera.position.z = distance * Math.cos(angle);
        camera.lookAt(controls.target);
      }
      state.rotation.frame = requestAnimationFrame(rotate);
    };
    rotate();
  } else if (state.ui.focusedNode) {
    const keepFocus = () => {
      const controls = state.graph.controls();
      if (controls && state.ui.focusedNode) {
        controls.target.set(
          state.ui.focusedNode.x || 0,
          state.ui.focusedNode.y || 0,
          state.ui.focusedNode.z || 0
        );
      }
      state.rotation.frame = requestAnimationFrame(keepFocus);
    };
    keepFocus();
  }
}

function initGraph3D(state) {
  const container = document.getElementById('graph-container');
  if (!container) {
    console.error('[DependViz] Container not found!');
    return false;
  }

  if (typeof ForceGraph3D === 'undefined') {
    console.error('[DependViz] ForceGraph3D is undefined!');
    return false;
  }

  try {
    // CSS2DRendererの初期化
    let renderer = null;
    if (typeof window.CSS2DRenderer !== 'undefined') {
      renderer = new window.CSS2DRenderer();
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.domElement.style.position = 'absolute';
      renderer.domElement.style.top = '0';
      renderer.domElement.style.pointerEvents = 'none';
      container.appendChild(renderer.domElement);
      state.setLabelRenderer(renderer);
    }

    const extraRenderers = renderer ? [renderer] : [];
    const g = ForceGraph3D({ extraRenderers })(container)
      .backgroundColor(state.getBackgroundColor())
      .linkDirectionalArrowLength(5)
      .linkDirectionalArrowRelPos(1)
      .onNodeClick(node => {
        if (!node || !vscode) return;
        const filePath = state._getNodeFilePath(node);
        if (filePath) {
          vscode.postMessage({
            type: 'focusNode',
            node: {
              id: node.id,
              filePath: filePath,
              name: node.name
            }
          });
        }
      });

    state.setGraph(g);

    // カメラコントロールイベント
    const controls = g.controls();
    if (controls) {
      controls.addEventListener('start', () => {
        state.ui.isUserInteracting = true;
        state.cancelRotation();
        updateAutoRotation(state);
      });
      controls.addEventListener('end', () => {
        state.cancelRotation();
        state.rotation.timeout = setTimeout(() => {
          state.ui.isUserInteracting = false;
          updateAutoRotation(state);
        }, DEBUG.AUTO_ROTATE_DELAY);
      });
    }

    return true;
  } catch (error) {
    console.error('[DependViz] Error initializing 3D graph:', error);
    return false;
  }
}


// メインレンダラー: 2D/3Dモードに応じて適切なレンダラーに委譲

const state = new GraphState();

// 共通ユーティリティ関数
function applyOpacityToColor(color, opacity) {
  if (opacity === undefined || opacity === 1) return color;

  // Handle hex colors
  if (color.startsWith('#')) {
    const hex = color.slice(1);
    const r = parseInt(hex.slice(0, 2), 16);
    const g = parseInt(hex.slice(2, 4), 16);
    const b = parseInt(hex.slice(4, 6), 16);
    return `rgba(${r}, ${g}, ${b}, ${opacity})`;
  }

  // Handle rgb/rgba
  if (color.startsWith('rgb')) {
    const match = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*[\d.]+)?\)/);
    if (match) {
      return `rgba(${match[1]}, ${match[2]}, ${match[3]}, ${opacity})`;
    }
  }

  return color;
}

function buildVisualCache(nodes, links, state) {
  const nodeVisualCache = new Map();
  const nodeById = new Map();

  nodes.forEach(node => {
    node.neighbors = [];
    node.links = [];
    nodeVisualCache.set(node, state.getNodeVisualProps(node));
    if (node.id != null) {
      nodeById.set(node.id, node);
    }
  });

  const linkVisualCache = new Map();
  links.forEach(link => {
    linkVisualCache.set(link, state.getLinkVisualProps(link));

    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
    const targetId = typeof link.target === 'object' ? link.target.id : link.target;

    const a = nodeById.get(sourceId);
    const b = nodeById.get(targetId);
    if (!a || !b) return;

    a.neighbors.push(b);
    b.neighbors.push(a);
    a.links.push(link);
    b.links.push(link);
  });

  return { nodeVisualCache, linkVisualCache };
}

function updateGraph(options = {}) {
  const { reheatSimulation = false } = options;

  if (!state.graph) {
    if (!state.initGraph()) {
      console.error('[DependViz] Failed to initialize graph');
      return;
    }
  }

  if (state.controls.is3DMode) {
    updateGraph3D(state, { reheatSimulation });
  } else {
    updateGraph2D(state, { reheatSimulation });
  }
}

function updateVisuals() {
  if (!state.graph) return;

  if (state.controls.is3DMode) {
    updateVisuals3D(state);
  } else {
    updateVisuals2D(state);
  }
}

function handleResize() {
  if (!state.graph) return;
  const container = document.getElementById('graph-container');
  if (!container) return;

  const width = container.clientWidth;
  const height = container.clientHeight;

  state.graph.width(width).height(height);
}

function focusNodeByPath(filePath) {
  if (!filePath) return;
  const node = state.data.nodes.find(n => state._pathsMatch(state._getNodeFilePath(n), filePath));
  if (node) {
    state.ui.focusedNode = node;
    if (state.controls.is3DMode) {
      focusNode3D(state, node);
    } else {
      focusNode2D(state, node);
    }
    updateVisuals();
  }
}

function focusNodeById(msg) {
  const nodeId = msg.nodeId || (msg.node && msg.node.id);
  const node = state.data.nodes.find(n => n.id === nodeId);

  if (!node) return;

  if (node.x === undefined || node.y === undefined) {
    setTimeout(() => focusNodeById(msg), 100);
    return;
  }

  state.ui.focusedNode = node;
  if (state.controls.is3DMode) {
    focusNode3D(state, node);
  } else {
    focusNode2D(state, node);
  }
  updateVisuals();
}


const messageHandlers = {
  data: msg => {
    state.updateData(msg.data);
    updateGraph({ reheatSimulation: true });
  },
  controls: msg => {
    state.updateControls(msg.controls);
    updateVisuals();
  },
  stackTrace: msg => {
    state.ui.stackTraceLinks = new Set(msg.paths.map(p => p.link));
    updateVisuals();
  },
  focusNode: msg => {
    const filePath = msg.filePath || (msg.node && msg.node.filePath);
    if (filePath) {
      focusNodeByPath(filePath);
    }
  },
  focusNodeById: msg => {
    focusNodeById(msg);
  },
  update: msg => {
    const hasDataChange = !!msg.data;
    const oldIs3DMode = state.controls.is3DMode;

    if (msg.data) {
      state.updateData(msg.data);
    }
    if (msg.controls) {
      state.updateControls(msg.controls);
    }
    if (msg.stackTracePaths) {
      state.ui.stackTraceLinks = new Set(msg.stackTracePaths.map(p => p.link));
    }

    // モードが変わった場合は完全に再初期化
    const modeChanged = msg.controls && (state.controls.is3DMode !== oldIs3DMode);

    if (hasDataChange || modeChanged) {
      updateGraph({ reheatSimulation: true });
    } else {
      updateVisuals();
    }
  },
  toggle3DMode: msg => {
    // controlsの更新が先に来るので、ここではグラフをリセットして再初期化するだけ
    state.toggleMode();
    // 次のcontrols更新メッセージでupdateGraphが呼ばれる
  }
};

if (vscode) {
  window.addEventListener('message', event => {
    const msg = event.data;
    const handler = messageHandlers[msg.type];
    if (handler) {
      handler(msg);
    } else {
      console.warn('[DependViz] Unknown message type:', msg.type);
    }
  });

  vscode.postMessage({ type: 'ready' });
}


window.addEventListener('resize', handleResize);

setTimeout(() => {
  if (state.initGraph()) {
    updateGraph();
  } else {
    console.error('[DependViz] Failed to initialize graph on startup');
  }
}, 100);

})(DEFAULT_CONTROLS, COLORS, DEBUG);
        }).catch(error => {
            console.error('[Template] Failed to load ForceGraph:', error);
            document.body.innerHTML = '<div style="color: red; padding: 20px;">Failed to load graph library: ' + error.message + '</div>';
        });
    </script>
</body>
</html>

