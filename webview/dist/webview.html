<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Security-Policy" content="default-src 'none'; img-src {{cspSource}} https: data:; script-src {{cspSource}} https://esm.sh 'nonce-{{nonce}}'; style-src {{cspSource}} 'unsafe-inline'; connect-src {{cspSource}};">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1e1e1e;
            color: #cccccc;
            overflow: hidden;
        }
        #graph-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
    </style>
</head>
<body>
    <div id="graph-container"></div>
    <script nonce="{{nonce}}" type="module">
        // @ts-nocheck
        import("{{fgUri}}").then(module => {
            window.ForceGraph = module.default || module.ForceGraph || module;

            const DEFAULT_CONTROLS = {{defaultControls}};
            const COLORS = {{colors}};
            const DEBUG = {{debug}};

            (function(DEFAULT_CONTROLS, COLORS, DEBUG) {
const vscode = typeof acquireVsCodeApi === 'function' ? acquireVsCodeApi() : null;


class GraphState {
  constructor() {
    this.data = { nodes: [], links: [] };
    this.controls = DEFAULT_CONTROLS;
    this.ui = {
      highlightLinks: new Set(),
      stackTraceLinks: new Set(),
      focusedNode: null
    };
    this._graph = null;
    this.nodeRules = [
      (node, ctx) => {
        const map = {
          Class: ctx.controls.colorClass,
          AbstractClass: ctx.controls.colorAbstractClass,
          Interface: ctx.controls.colorInterface,
          Unknown: ctx.controls.colorUnknown
        };
        return map[node.type] ? { color: map[node.type] } : null;
      },
      (node, ctx) => ctx.controls.nodeSizeByLoc && node.linesOfCode > 0 && {
        sizeMultiplier: Math.max(1, Math.pow(node.linesOfCode, 0.7))
      }
    ];
    this.linkRules = [
      (link, ctx) => ctx.ui.stackTraceLinks.has(link) && {
        color: COLORS.STACK_TRACE_LINK,
        widthMultiplier: 2.5,
        particles: 5
      },
      (link, ctx) => ctx.ui.highlightLinks.has(link) && {
        widthMultiplier: 2,
        particles: 4
      },
      (link, ctx) => {
        const map = {
          ObjectCreate: ctx.controls.colorObjectCreate,
          Extends: ctx.controls.colorExtends,
          Implements: ctx.controls.colorImplements,
          TypeUse: ctx.controls.colorTypeUse,
          MethodCall: ctx.controls.colorMethodCall
        };
        return map[link.type] ? { color: map[link.type] } : null;
      }
    ];
  }

  get graph() { return this._graph; }

  setGraph(graph) { this._graph = graph; }

  getBackgroundColor() {
    const style = getComputedStyle(document.body);
    const bgColor = style.getPropertyValue('--vscode-editor-background').trim();
    return bgColor || COLORS.BACKGROUND_DARK;
  }

  updateData(data) {
    this.data = { nodes: [...(data.nodes || [])], links: [...(data.links || [])] };
  }

  updateControls(controls) {
    this.controls = { ...this.controls, ...controls };
  }

  _getNodeFilePath(node) {
    return node.filePath || node.file;
  }

  _normalizePath(path) {
    if (!path) return '';
    let normalized = path.replace(/\\/g, '/');
    normalized = normalized.replace(/\/+$/, '');
    const parts = normalized.split('/').filter(p => p && p !== '.');
    const result = [];
    for (const part of parts) {
      if (part === '..') {
        if (result.length > 0 && result[result.length - 1] !== '..') {
          result.pop();
        } else {
          result.push(part);
        }
      } else {
        result.push(part);
      }
    }
    return result.join('/');
  }

  _pathsMatch(path1, path2) {
    if (!path1 || !path2) return false;
    const norm1 = this._normalizePath(path1);
    const norm2 = this._normalizePath(path2);
    if (norm1 === norm2) return true;
    const parts1 = norm1.split('/').filter(Boolean);
    const parts2 = norm2.split('/').filter(Boolean);
    if (parts1.length === 0 || parts2.length === 0) return false;
    const minLen = Math.min(parts1.length, parts2.length);
    if (minLen < 2) return false;
    for (let i = 1; i <= minLen; i++) {
      const suffix1 = parts1.slice(-i).join('/');
      const suffix2 = parts2.slice(-i).join('/');
      if (suffix1 === suffix2) return true;
    }
    return false;
  }

  _computeNodeLabel(node) {
    if (!node.name) return node.id || '';
    if (!this.controls.shortNames) return node.name;
    const lastDot = node.name.lastIndexOf('.');
    return lastDot !== -1 ? node.name.substring(lastDot + 1) : node.name;
  }

  _applyRules(item, rules, defaults) {
    const result = { ...defaults };
    for (const rule of rules) {
      const ruleResult = rule(item, this);
      if (ruleResult) Object.assign(result, ruleResult);
    }
    return result;
  }

  getNodeVisualProps(node) {
    const props = this._applyRules(node, this.nodeRules, {
      color: COLORS.NODE_DEFAULT,
      sizeMultiplier: 1,
      label: this._computeNodeLabel(node),
      opacity: this.controls.nodeOpacity
    });

    // Apply focus dimming
    if (this.ui.focusedNode) {
      const isFocused = node.id === this.ui.focusedNode.id;
      const isNeighbor = this.ui.focusedNode.neighbors &&
                         this.ui.focusedNode.neighbors.some(n => n.id === node.id);

      if (!isFocused && !isNeighbor) {
        props.opacity = (props.opacity || 1) * 0.2;
      }
    }

    return { ...props, size: (props.sizeMultiplier || 1) * this.controls.nodeSize };
  }

  getLinkVisualProps(link) {
    const props = this._applyRules(link, this.linkRules, {
      color: COLORS.EDGE_DEFAULT,
      widthMultiplier: 1,
      particles: 0,
      opacity: this.controls.edgeOpacity,
      arrowSize: this.controls.arrowSize
    });

    // Apply focus dimming and highlighting
    if (this.ui.focusedNode) {
      const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
      const targetId = typeof link.target === 'object' ? link.target.id : link.target;
      const focusedId = this.ui.focusedNode.id;

      const isConnectedToFocus = sourceId === focusedId || targetId === focusedId;

      if (isConnectedToFocus) {
        // Add particles to focused edges
        props.particles = 3;
        props.widthMultiplier = (props.widthMultiplier || 1) * 1.5;
      } else {
        props.opacity = (props.opacity || 1) * 0.1;
      }
    }

    return { ...props, width: (props.widthMultiplier || 1) * this.controls.linkWidth };
  }

  initGraph() {
    const container = document.getElementById('graph-container');

    if (!container) {
      console.error('[DependViz] Container not found!');
      return false;
    }

    if (typeof ForceGraph === 'undefined') {
      console.error('[DependViz] ForceGraph is undefined!');
      return false;
    }

    try {
      const g = ForceGraph()(container)
        .backgroundColor(this.getBackgroundColor())
        .linkDirectionalArrowLength(5)
        .linkDirectionalArrowRelPos(1)
        .onNodeClick(node => {
          if (!node || !vscode) return;
          const filePath = state._getNodeFilePath(node);
          if (filePath) {
            vscode.postMessage({
              type: 'focusNode',
              node: {
                id: node.id,
                filePath: filePath,
                name: node.name
              }
            });
          }
        });
      this.setGraph(g);
      return true;
    } catch (error) {
      console.error('[DependViz] Error initializing graph:', error);
      return false;
    }
  }
}


function applyFilter(nodes, links) {
  const controls = state.controls;

  let filteredNodes = nodes.filter(node => {
    if (!controls[`show${node.type}`]) return false;
    if (controls.hideIsolatedNodes && (!node.neighbors || node.neighbors.length === 0)) return false;
    if (controls.search && !matchesSearchQuery(node, controls.search)) return false;
    return true;
  });

  if (state.ui.focusedNode && (controls.enableForwardSlice || controls.enableBackwardSlice)) {
    const sliceNodes = new Set();
    sliceNodes.add(state.ui.focusedNode.id);

    if (controls.enableForwardSlice) {
      traverseSlice(state.ui.focusedNode, 'forward', controls.sliceDepth, sliceNodes, nodes, links);
    }
    if (controls.enableBackwardSlice) {
      traverseSlice(state.ui.focusedNode, 'backward', controls.sliceDepth, sliceNodes, nodes, links);
    }

    filteredNodes = filteredNodes.filter(node => sliceNodes.has(node.id));
  }

  const nodeIds = new Set(filteredNodes.map(n => n.id));
  const filteredLinks = links.filter(link => {
    if (!controls[`show${link.type}`]) return false;
    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
    return nodeIds.has(sourceId) && nodeIds.has(targetId);
  });

  return { nodes: filteredNodes, links: filteredLinks };
}

function traverseSlice(node, direction, depth, visited, allNodes, allLinks) {
  if (depth <= 0) return;

  const relevantLinks = allLinks.filter(link => {
    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
    return direction === 'forward' ? sourceId === node.id : targetId === node.id;
  });

  relevantLinks.forEach(link => {
    const nextNodeId = direction === 'forward'
      ? (typeof link.target === 'object' ? link.target.id : link.target)
      : (typeof link.source === 'object' ? link.source.id : link.source);

    if (!visited.has(nextNodeId)) {
      visited.add(nextNodeId);
      const nextNode = allNodes.find(n => n.id === nextNodeId);
      if (nextNode) {
        traverseSlice(nextNode, direction, depth - 1, visited, allNodes, allLinks);
      }
    }
  });
}

function matchesSearchQuery(node, query) {
  if (!query) return true;
  const q = query.toLowerCase();

  if (q.includes(':')) {
    const hasAnd = q.includes(' and ');
    const hasOr = q.includes(' or ');
    const parts = q.split(/\s+and\s+|\s+or\s+/).map(s => s.trim());

    const results = parts.map(subQ => {
      if (subQ.startsWith('not ')) {
        return !evaluateFieldQuery(node, subQ.substring(4));
      }
      return evaluateFieldQuery(node, subQ);
    });

    if (hasAnd && !hasOr) return results.every(Boolean);
    if (hasOr && !hasAnd) return results.some(Boolean);
    if (hasAnd && hasOr) return results.every(Boolean);
    return results[0];
  }

  return (node.name && node.name.toLowerCase().includes(q)) ||
         (node.id && node.id.toLowerCase().includes(q));
}

function evaluateFieldQuery(node, query) {
  const match = query.match(/^(\w+):(.+)$/);
  if (!match) return false;

  const [, field, rawValue] = match;
  const isRegex = rawValue.startsWith('/') && rawValue.endsWith('/');
  const searchValue = isRegex ? rawValue.slice(1, -1) : rawValue;

  let nodeValue = '';
  if (field === 'name') nodeValue = node.name || '';
  else if (field === 'type') nodeValue = node.type || '';
  else if (field === 'path') nodeValue = node.filePath || node.file || '';

  if (isRegex) {
    try {
      return new RegExp(searchValue, 'i').test(nodeValue);
    } catch (e) {
      return false;
    }
  }

  return nodeValue.toLowerCase().includes(searchValue.toLowerCase());
}


const state = new GraphState();

function applyOpacityToColor(color, opacity) {
  if (opacity === undefined || opacity === 1) return color;

  // Handle hex colors
  if (color.startsWith('#')) {
    const hex = color.slice(1);
    const r = parseInt(hex.slice(0, 2), 16);
    const g = parseInt(hex.slice(2, 4), 16);
    const b = parseInt(hex.slice(4, 6), 16);
    return `rgba(${r}, ${g}, ${b}, ${opacity})`;
  }

  // Handle rgb/rgba
  if (color.startsWith('rgb')) {
    const match = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*[\d.]+)?\)/);
    if (match) {
      return `rgba(${match[1]}, ${match[2]}, ${match[3]}, ${opacity})`;
    }
  }

  return color;
}

function updateGraph(options = {}) {
  const { reheatSimulation = false } = options;

  if (!state.graph) {
    if (!state.initGraph()) {
      console.error('[DependViz] Failed to initialize graph');
      return;
    }
  }

  state.graph.backgroundColor(state.getBackgroundColor());

  const nodes = state.data.nodes || [];
  const links = state.data.links || [];

  const nodeVisualCache = new Map();
  const nodeById = new Map();
  nodes.forEach(node => {
    node.neighbors = [];
    node.links = [];
    nodeVisualCache.set(node, state.getNodeVisualProps(node));
    if (node.id != null) {
      nodeById.set(node.id, node);
    }
  });

  const linkVisualCache = new Map();
  links.forEach(link => {
    linkVisualCache.set(link, state.getLinkVisualProps(link));

    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
    const targetId = typeof link.target === 'object' ? link.target.id : link.target;

    const a = nodeById.get(sourceId);
    const b = nodeById.get(targetId);
    if (!a || !b) return;

    a.neighbors.push(b);
    b.neighbors.push(a);
    a.links.push(link);
    b.links.push(link);
  });

  const getNodeProps = node => nodeVisualCache.get(node);
  const getLinkProps = link => linkVisualCache.get(link);

  const filteredData = applyFilter(nodes, links);

  state.graph.graphData(filteredData);

  if (state.controls.showNames) {
    state.graph
      .nodeCanvasObject((node, ctx, globalScale) => {
        const props = getNodeProps(node);
        if (!props) return;
        const label = props.label || node.name || node.id;
        const fontSize = state.controls.textSize || 12;
        ctx.font = `${fontSize}px Sans-Serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = applyOpacityToColor('#ffffff', props.opacity);
        ctx.fillText(label, node.x, node.y);
      })
      .nodeCanvasObjectMode(() => 'after');
  } else {
    state.graph.nodeCanvasObjectMode(() => null);
  }

  state.graph
    .nodeLabel(node => {
      const props = getNodeProps(node);
      return props ? props.label : node.name || node.id;
    })
    .nodeColor(node => {
      const props = getNodeProps(node);
      const color = props ? props.color : COLORS.NODE_DEFAULT;
      return applyOpacityToColor(color, props?.opacity);
    })
    .nodeVal(node => {
      const props = getNodeProps(node);
      return props ? props.size : state.controls.nodeSize;
    })
    .linkColor(link => {
      const props = getLinkProps(link);
      const color = props ? props.color : COLORS.EDGE_DEFAULT;
      return applyOpacityToColor(color, props?.opacity);
    })
    .linkWidth(link => {
      const props = getLinkProps(link);
      return props ? props.width : state.controls.linkWidth;
    })
    .linkDirectionalArrowLength(state.controls.arrowSize)
    .linkDirectionalParticles(link => {
      const props = getLinkProps(link);
      return props ? (props.particles || 0) : 0;
    })
    .linkDirectionalParticleWidth(2);

  const linkForce = state.graph.d3Force('link');
  if (linkForce) linkForce.distance(state.controls.linkDistance);

  if (reheatSimulation && state.graph?.d3ReheatSimulation) {
    setTimeout(() => state.graph.d3ReheatSimulation(), 100);
  }
}

function updateVisuals() {
  if (!state.graph) return;

  const nodes = state.data.nodes || [];
  const links = state.data.links || [];

  const nodeVisualCache = new Map();
  nodes.forEach(node => {
    nodeVisualCache.set(node, state.getNodeVisualProps(node));
  });

  const linkVisualCache = new Map();
  links.forEach(link => {
    linkVisualCache.set(link, state.getLinkVisualProps(link));
  });

  const getNodeProps = node => nodeVisualCache.get(node);
  const getLinkProps = link => linkVisualCache.get(link);

  if (state.controls.showNames) {
    state.graph
      .nodeCanvasObject((node, ctx, globalScale) => {
        const props = getNodeProps(node);
        if (!props) return;
        const label = props.label || node.name || node.id;
        const fontSize = state.controls.textSize || 12;
        ctx.font = `${fontSize}px Sans-Serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = applyOpacityToColor('#ffffff', props.opacity);
        ctx.fillText(label, node.x, node.y);
      })
      .nodeCanvasObjectMode(() => 'after');
  } else {
    state.graph.nodeCanvasObjectMode(() => null);
  }

  state.graph
    .nodeColor(node => {
      const props = getNodeProps(node);
      const color = props ? props.color : COLORS.NODE_DEFAULT;
      return applyOpacityToColor(color, props?.opacity);
    })
    .linkColor(link => {
      const props = getLinkProps(link);
      const color = props ? props.color : COLORS.EDGE_DEFAULT;
      return applyOpacityToColor(color, props?.opacity);
    })
    .linkDirectionalParticles(link => {
      const props = getLinkProps(link);
      return props ? (props.particles || 0) : 0;
    });
}

function handleResize() {
  if (!state.graph) return;
  const container = document.getElementById('graph-container');
  if (!container) return;

  const width = container.clientWidth;
  const height = container.clientHeight;

  state.graph.width(width).height(height);
}

function focusNodeByPath(filePath) {
  if (!filePath) return;
  const node = state.data.nodes.find(n => state._pathsMatch(state._getNodeFilePath(n), filePath));
  if (node) {
    state.ui.focusedNode = node;
    if (state.graph && node.x !== undefined && node.y !== undefined) {
      state.graph.centerAt(node.x, node.y, 1000);
    }
    updateVisuals();
  }
}

function focusNodeById(msg) {
  const nodeId = msg.nodeId || (msg.node && msg.node.id);
  const node = state.data.nodes.find(n => n.id === nodeId);

  if (!node) return;

  if (node.x === undefined || node.y === undefined) {
    setTimeout(() => focusNodeById(msg), 100);
    return;
  }

  state.ui.focusedNode = node;
  state.graph.centerAt(node.x, node.y, 1000);
  updateVisuals();
}


const messageHandlers = {
  data: msg => {
    state.updateData(msg.data);
    updateGraph({ reheatSimulation: true });
  },
  controls: msg => {
    state.updateControls(msg.controls);
    updateVisuals();
  },
  stackTrace: msg => {
    state.ui.stackTraceLinks = new Set(msg.paths.map(p => p.link));
    updateVisuals();
  },
  focusNode: msg => {
    const filePath = msg.filePath || (msg.node && msg.node.filePath);
    if (filePath) {
      focusNodeByPath(filePath);
    }
  },
  focusNodeById: msg => {
    focusNodeById(msg);
  },
  update: msg => {
    const hasDataChange = !!msg.data;

    if (msg.data) {
      state.updateData(msg.data);
    }
    if (msg.controls) {
      state.updateControls(msg.controls);
    }
    if (msg.stackTracePaths) {
      state.ui.stackTraceLinks = new Set(msg.stackTracePaths.map(p => p.link));
    }

    if (hasDataChange) {
      updateGraph({ reheatSimulation: true });
    } else {
      updateVisuals();
    }
  }
};

if (vscode) {
  window.addEventListener('message', event => {
    const msg = event.data;
    const handler = messageHandlers[msg.type];
    if (handler) {
      handler(msg);
    } else {
      console.warn('[DependViz] Unknown message type:', msg.type);
    }
  });

  vscode.postMessage({ type: 'ready' });
}


window.addEventListener('resize', handleResize);

setTimeout(() => {
  if (state.initGraph()) {
    updateGraph();
  } else {
    console.error('[DependViz] Failed to initialize graph on startup');
  }
}, 100);

})(DEFAULT_CONTROLS, COLORS, DEBUG);
        }).catch(error => {
            console.error('[Template] Failed to load ForceGraph:', error);
            document.body.innerHTML = '<div style="color: red; padding: 20px;">Failed to load graph library: ' + error.message + '</div>';
        });
    </script>
</body>
</html>

