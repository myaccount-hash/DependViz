<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Security-Policy" content="default-src 'none'; img-src {{cspSource}} https: data:; script-src {{cspSource}} https://esm.sh 'nonce-{{nonce}}'; style-src {{cspSource}} 'unsafe-inline'; connect-src {{cspSource}};">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1e1e1e;
            color: #cccccc;
            overflow: hidden;
        }
        #graph-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
    </style>
</head>
<body>
    <div id="graph-container"></div>
    <script nonce="{{nonce}}" type="module">
        // @ts-nocheck
        Promise.all([
            import("{{fgUri}}"),
            import("{{fg3dUri}}"),
            import('https://esm.sh/three/examples/jsm/renderers/CSS2DRenderer.js')
        ]).then(([fg2dModule, fg3dModule, css2dModule]) => {
            window.ForceGraph = fg2dModule.default || fg2dModule.ForceGraph || fg2dModule;
            window.ForceGraph3D = fg3dModule.default || fg3dModule.ForceGraph3D || fg3dModule;
            window.CSS2DRenderer = css2dModule.CSS2DRenderer;
            window.CSS2DObject = css2dModule.CSS2DObject;

            const DEFAULT_CONTROLS = {{defaultControls}};
            const COLORS = {{colors}};
            const DEBUG = {{debug}};

            (function(DEFAULT_CONTROLS, COLORS, DEBUG) {
let vscode = null;
if (typeof acquireVsCodeApi === 'function') {
    vscode = acquireVsCodeApi();
}


class GraphState {
  constructor() {
    this.data = { nodes: [], links: [] };
    this.controls = DEFAULT_CONTROLS;
    this.ui = {
      highlightLinks: new Set(),
      stackTraceLinks: new Set(),
      focusedNode: null,
      isUserInteracting: false
    };
    this.rotation = {
      frame: null,
      startTime: null,
      startAngle: null,
      timeout: null
    };
    this._graph = null;
    this._labelRenderer = null;
    this.nodeRules = [
      (node, ctx) => {
        const map = {
          Class: ctx.controls.colorClass,
          AbstractClass: ctx.controls.colorAbstractClass,
          Interface: ctx.controls.colorInterface,
          Unknown: ctx.controls.colorUnknown
        };
        return map[node.type] ? { color: map[node.type] } : null;
      },
      (node, ctx) => ctx.controls.nodeSizeByLoc && node.linesOfCode > 0 && {
        sizeMultiplier: Math.max(1, Math.pow(node.linesOfCode, 0.7))
      }
    ];
    this.linkRules = [
      (link, ctx) => ctx.ui.stackTraceLinks.has(link) && {
        color: COLORS.STACK_TRACE_LINK,
        widthMultiplier: 2.5,
        particles: 5
      },
      (link, ctx) => ctx.ui.highlightLinks.has(link) && {
        widthMultiplier: 2,
        particles: 4
      },
      (link, ctx) => {
        const map = {
          ObjectCreate: ctx.controls.colorObjectCreate,
          Extends: ctx.controls.colorExtends,
          Implements: ctx.controls.colorImplements,
          TypeUse: ctx.controls.colorTypeUse,
          MethodCall: ctx.controls.colorMethodCall
        };
        return map[link.type] ? { color: map[link.type] } : null;
      }
    ];
  }

  get graph() { return this._graph; }
  get labelRenderer() { return this._labelRenderer; }

  setGraph(graph) { this._graph = graph; }
  setLabelRenderer(renderer) { this._labelRenderer = renderer; }

  getBackgroundColor() {
    const style = getComputedStyle(document.body);
    const bgColor = style.getPropertyValue('--vscode-editor-background').trim();
    return bgColor || COLORS.BACKGROUND_DARK;
  }

  updateData(data) {
    this.data = { nodes: [...(data.nodes || [])], links: [...(data.links || [])] };
  }

  updateControls(controls) {
    this.controls = { ...this.controls, ...controls };
  }

  _getNodeFilePath(node) {
    return node.filePath || node.file;
  }

  _normalizePath(path) {
    if (!path) return '';
    let normalized = path.replace(/\\/g, '/');
    normalized = normalized.replace(/\/+$/, '');
    const parts = normalized.split('/').filter(p => p && p !== '.');
    const result = [];
    for (const part of parts) {
      if (part === '..') {
        if (result.length > 0 && result[result.length - 1] !== '..') {
          result.pop();
        } else {
          result.push(part);
        }
      } else {
        result.push(part);
      }
    }
    return result.join('/');
  }

  _pathsMatch(path1, path2) {
    if (!path1 || !path2) return false;
    const norm1 = this._normalizePath(path1);
    const norm2 = this._normalizePath(path2);
    if (norm1 === norm2) return true;
    const parts1 = norm1.split('/').filter(Boolean);
    const parts2 = norm2.split('/').filter(Boolean);
    if (parts1.length === 0 || parts2.length === 0) return false;
    const minLen = Math.min(parts1.length, parts2.length);
    if (minLen < 2) return false;
    for (let i = 1; i <= minLen; i++) {
      const suffix1 = parts1.slice(-i).join('/');
      const suffix2 = parts2.slice(-i).join('/');
      if (suffix1 === suffix2) return true;
    }
    return false;
  }

  _computeNodeLabel(node) {
    if (!node.name) return node.id || '';
    if (!this.controls.shortNames) return node.name;
    const lastDot = node.name.lastIndexOf('.');
    return lastDot !== -1 ? node.name.substring(lastDot + 1) : node.name;
  }

  _applyRules(item, rules, defaults) {
    const result = { ...defaults };
    for (const rule of rules) {
      const ruleResult = rule(item, this);
      if (ruleResult) Object.assign(result, ruleResult);
    }
    return result;
  }

  getNodeVisualProps(node) {
    const props = this._applyRules(node, this.nodeRules, {
      color: COLORS.NODE_DEFAULT,
      sizeMultiplier: 1,
      label: this._computeNodeLabel(node),
      opacity: this.controls.nodeOpacity
    });

    // Apply focus dimming
    if (this.ui.focusedNode) {
      const isFocused = node.id === this.ui.focusedNode.id;
      const isNeighbor = this.ui.focusedNode.neighbors &&
                         this.ui.focusedNode.neighbors.some(n => n.id === node.id);

      if (!isFocused && !isNeighbor) {
        props.opacity = (props.opacity || 1) * 0.2;
      }
    }

    return { ...props, size: (props.sizeMultiplier || 1) * this.controls.nodeSize };
  }

  getLinkVisualProps(link) {
    const props = this._applyRules(link, this.linkRules, {
      color: COLORS.EDGE_DEFAULT,
      widthMultiplier: 1,
      particles: 0,
      opacity: this.controls.edgeOpacity,
      arrowSize: this.controls.arrowSize
    });

    // Apply focus dimming and highlighting
    if (this.ui.focusedNode) {
      const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
      const targetId = typeof link.target === 'object' ? link.target.id : link.target;
      const focusedId = this.ui.focusedNode.id;

      const isConnectedToFocus = sourceId === focusedId || targetId === focusedId;

      if (isConnectedToFocus) {
        // Add particles to focused edges
        props.particles = 3;
        props.widthMultiplier = (props.widthMultiplier || 1) * 1.5;
      } else {
        props.opacity = (props.opacity || 1) * 0.1;
      }
    }

    return { ...props, width: (props.widthMultiplier || 1) * this.controls.linkWidth };
  }

  initGraph() {
    const renderer = this.controls.is3DMode
      ? new GraphRenderer3D(this)
      : new GraphRenderer2D(this);
    return renderer.initGraph();
  }

  toggleMode() {
    // 設定値は外部（GraphViewProvider）で更新されるので、ここではグラフをリセットするだけ
    if (this.rotation.frame) {
      cancelAnimationFrame(this.rotation.frame);
      this.rotation.frame = null;
    }
    clearTimeout(this.rotation.timeout);
    this._graph = null;
    this._labelRenderer = null;
  }
}


function applyFilter(nodes, links) {
  const controls = state.controls;

  let filteredNodes = nodes.filter(node => {
    if (!controls[`show${node.type}`]) return false;
    if (controls.hideIsolatedNodes && (!node.neighbors || node.neighbors.length === 0)) return false;
    if (controls.search && !matchesSearchQuery(node, controls.search)) return false;
    return true;
  });

  if (state.ui.focusedNode && (controls.enableForwardSlice || controls.enableBackwardSlice)) {
    const sliceNodes = new Set();
    sliceNodes.add(state.ui.focusedNode.id);

    if (controls.enableForwardSlice) {
      traverseSlice(state.ui.focusedNode, 'forward', controls.sliceDepth, sliceNodes, nodes, links);
    }
    if (controls.enableBackwardSlice) {
      traverseSlice(state.ui.focusedNode, 'backward', controls.sliceDepth, sliceNodes, nodes, links);
    }

    filteredNodes = filteredNodes.filter(node => sliceNodes.has(node.id));
  }

  const nodeIds = new Set(filteredNodes.map(n => n.id));
  const filteredLinks = links.filter(link => {
    if (!controls[`show${link.type}`]) return false;
    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
    return nodeIds.has(sourceId) && nodeIds.has(targetId);
  });

  return { nodes: filteredNodes, links: filteredLinks };
}

function traverseSlice(node, direction, depth, visited, allNodes, allLinks) {
  if (depth <= 0) return;

  const relevantLinks = allLinks.filter(link => {
    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
    return direction === 'forward' ? sourceId === node.id : targetId === node.id;
  });

  relevantLinks.forEach(link => {
    const nextNodeId = direction === 'forward'
      ? (typeof link.target === 'object' ? link.target.id : link.target)
      : (typeof link.source === 'object' ? link.source.id : link.source);

    if (!visited.has(nextNodeId)) {
      visited.add(nextNodeId);
      const nextNode = allNodes.find(n => n.id === nextNodeId);
      if (nextNode) {
        traverseSlice(nextNode, direction, depth - 1, visited, allNodes, allLinks);
      }
    }
  });
}

function matchesSearchQuery(node, query) {
  if (!query) return true;
  const q = query.toLowerCase();

  if (q.includes(':')) {
    const hasAnd = q.includes(' and ');
    const hasOr = q.includes(' or ');
    const parts = q.split(/\s+and\s+|\s+or\s+/).map(s => s.trim());

    const results = parts.map(subQ => {
      if (subQ.startsWith('not ')) {
        return !evaluateFieldQuery(node, subQ.substring(4));
      }
      return evaluateFieldQuery(node, subQ);
    });

    if (hasAnd && !hasOr) return results.every(Boolean);
    if (hasOr && !hasAnd) return results.some(Boolean);
    if (hasAnd && hasOr) return results.every(Boolean);
    return results[0];
  }

  return (node.name && node.name.toLowerCase().includes(q)) ||
         (node.id && node.id.toLowerCase().includes(q));
}

function evaluateFieldQuery(node, query) {
  const match = query.match(/^(\w+):(.+)$/);
  if (!match) return false;

  const [, field, rawValue] = match;
  const isRegex = rawValue.startsWith('/') && rawValue.endsWith('/');
  const searchValue = isRegex ? rawValue.slice(1, -1) : rawValue;

  let nodeValue = '';
  if (field === 'name') nodeValue = node.name || '';
  else if (field === 'type') nodeValue = node.type || '';
  else if (field === 'path') nodeValue = node.filePath || node.file || '';

  if (isRegex) {
    try {
      return new RegExp(searchValue, 'i').test(nodeValue);
    } catch (e) {
      return false;
    }
  }

  return nodeValue.toLowerCase().includes(searchValue.toLowerCase());
}


// Base GraphRenderer class with common logic

class GraphRenderer {
  constructor(state) {
    this.state = state;
  }

  // Common graph update logic
  updateGraph(options = {}) {
    const { reheatSimulation = false } = options;

    if (!this.state.graph) {
      console.error('[DependViz] Graph not initialized');
      return;
    }

    this.state.graph.backgroundColor(this.state.getBackgroundColor());

    const nodes = this.state.data.nodes || [];
    const links = this.state.data.links || [];

    const { nodeVisualCache, linkVisualCache } = buildVisualCache(nodes, links, this.state);
    const getNodeProps = node => nodeVisualCache.get(node);
    const getLinkProps = link => linkVisualCache.get(link);

    const filteredData = applyFilter(nodes, links);
    this.state.graph.graphData(filteredData);

    // Apply labels using renderer-specific label renderer
    const labelRenderer = this.createLabelRenderer();
    if (this.state.controls.showNames) {
      labelRenderer.apply(this.state.graph, getNodeProps);
    } else {
      labelRenderer.clear(this.state.graph);
    }

    // Common graph properties
    this.state.graph
      .nodeLabel(node => {
        const props = getNodeProps(node);
        return props ? props.label : node.name || node.id;
      })
      .nodeColor(node => {
        const props = getNodeProps(node);
        const color = props ? props.color : COLORS.NODE_DEFAULT;
        return applyOpacityToColor(color, props?.opacity);
      })
      .nodeVal(node => {
        const props = getNodeProps(node);
        return props ? props.size : this.state.controls.nodeSize;
      })
      .linkColor(link => {
        const props = getLinkProps(link);
        const color = props ? props.color : COLORS.EDGE_DEFAULT;
        return applyOpacityToColor(color, props?.opacity);
      })
      .linkWidth(link => {
        const props = getLinkProps(link);
        return props ? props.width : this.state.controls.linkWidth;
      })
      .linkDirectionalArrowLength(this.state.controls.arrowSize)
      .linkDirectionalParticles(link => {
        const props = getLinkProps(link);
        return props ? (props.particles || 0) : 0;
      })
      .linkDirectionalParticleWidth(2);

    const linkForce = this.state.graph.d3Force('link');
    if (linkForce) linkForce.distance(this.state.controls.linkDistance);

    if (reheatSimulation && this.state.graph?.d3ReheatSimulation) {
      setTimeout(() => this.state.graph.d3ReheatSimulation(), 100);
    }

    // Subclass-specific post-update logic
    this.onGraphUpdated();
  }

  // Common visual update logic
  updateVisuals() {
    if (!this.state.graph) return;

    const nodes = this.state.data.nodes || [];
    const links = this.state.data.links || [];

    const { nodeVisualCache, linkVisualCache } = buildVisualCache(nodes, links, this.state);
    const getNodeProps = node => nodeVisualCache.get(node);
    const getLinkProps = link => linkVisualCache.get(link);

    // Apply labels
    const labelRenderer = this.createLabelRenderer();
    if (this.state.controls.showNames) {
      labelRenderer.apply(this.state.graph, getNodeProps);
    } else {
      labelRenderer.clear(this.state.graph);
    }

    this.state.graph
      .nodeColor(node => {
        const props = getNodeProps(node);
        const color = props ? props.color : COLORS.NODE_DEFAULT;
        return applyOpacityToColor(color, props?.opacity);
      })
      .linkColor(link => {
        const props = getLinkProps(link);
        const color = props ? props.color : COLORS.EDGE_DEFAULT;
        return applyOpacityToColor(color, props?.opacity);
      })
      .linkDirectionalParticles(link => {
        const props = getLinkProps(link);
        return props ? (props.particles || 0) : 0;
      });
  }

  // Common initialization logic
  initGraph() {
    const container = document.getElementById('graph-container');
    if (!container) {
      console.error('[DependViz] Container not found!');
      return false;
    }

    if (!this.checkLibraryAvailability()) {
      console.error(`[DependViz] ${this.getLibraryName()} is undefined!`);
      return false;
    }

    try {
      this.setupRenderer(container);
      const graph = this.createGraph(container);

      graph
        .backgroundColor(this.state.getBackgroundColor())
        .linkDirectionalArrowLength(5)
        .linkDirectionalArrowRelPos(1)
        .onNodeClick(node => {
          if (!node || !vscode) return;
          const filePath = this.state._getNodeFilePath(node);
          if (filePath) {
            vscode.postMessage({
              type: 'focusNode',
              node: {
                id: node.id,
                filePath: filePath,
                name: node.name
              }
            });
          }
        });

      this.state.setGraph(graph);
      this.setupEventListeners(graph);

      return true;
    } catch (error) {
      console.error(`[DependViz] Error initializing ${this.getModeName()} graph:`, error);
      return false;
    }
  }

  // Methods to be implemented by subclasses
  createLabelRenderer() {
    throw new Error('createLabelRenderer() must be implemented by subclass');
  }

  createGraph(container) {
    throw new Error('createGraph() must be implemented by subclass');
  }

  focusNode(node) {
    throw new Error('focusNode() must be implemented by subclass');
  }

  checkLibraryAvailability() {
    throw new Error('checkLibraryAvailability() must be implemented by subclass');
  }

  getLibraryName() {
    throw new Error('getLibraryName() must be implemented by subclass');
  }

  getModeName() {
    throw new Error('getModeName() must be implemented by subclass');
  }

  // Optional hooks for subclasses
  setupRenderer(container) {
    // Override if needed
  }

  setupEventListeners(graph) {
    // Override if needed
  }

  onGraphUpdated() {
    // Override if needed
  }
}

// Shared state and utility functions
const state = new GraphState();

function applyOpacityToColor(color, opacity) {
  if (opacity === undefined || opacity === 1) return color;

  // Handle hex colors
  if (color.startsWith('#')) {
    const hex = color.slice(1);
    const r = parseInt(hex.slice(0, 2), 16);
    const g = parseInt(hex.slice(2, 4), 16);
    const b = parseInt(hex.slice(4, 6), 16);
    return `rgba(${r}, ${g}, ${b}, ${opacity})`;
  }

  // Handle rgb/rgba
  if (color.startsWith('rgb')) {
    const match = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*[\d.]+)?\)/);
    if (match) {
      return `rgba(${match[1]}, ${match[2]}, ${match[3]}, ${opacity})`;
    }
  }

  return color;
}

function buildVisualCache(nodes, links, state) {
  const nodeVisualCache = new Map();
  const nodeById = new Map();

  nodes.forEach(node => {
    node.neighbors = [];
    node.links = [];
    nodeVisualCache.set(node, state.getNodeVisualProps(node));
    if (node.id != null) {
      nodeById.set(node.id, node);
    }
  });

  const linkVisualCache = new Map();
  links.forEach(link => {
    linkVisualCache.set(link, state.getLinkVisualProps(link));

    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
    const targetId = typeof link.target === 'object' ? link.target.id : link.target;

    const a = nodeById.get(sourceId);
    const b = nodeById.get(targetId);
    if (!a || !b) return;

    a.neighbors.push(b);
    b.neighbors.push(a);
    a.links.push(link);
    b.links.push(link);
  });

  return { nodeVisualCache, linkVisualCache };
}

// Global render manager
let currentRenderer = null;

function getRenderer() {
  if (!currentRenderer || currentRenderer.state.controls.is3DMode !== state.controls.is3DMode) {
    currentRenderer = state.controls.is3DMode
      ? new GraphRenderer3D(state)
      : new GraphRenderer2D(state);
  }
  return currentRenderer;
}

function updateGraph(options = {}) {
  const { reheatSimulation = false } = options;

  if (!state.graph) {
    if (!state.initGraph()) {
      console.error('[DependViz] Failed to initialize graph');
      return;
    }
  }

  getRenderer().updateGraph({ reheatSimulation });
}

function updateVisuals() {
  if (!state.graph) return;
  getRenderer().updateVisuals();
}

function handleResize() {
  if (!state.graph) return;
  const container = document.getElementById('graph-container');
  if (!container) return;

  const width = container.clientWidth;
  const height = container.clientHeight;

  state.graph.width(width).height(height);
}

function focusNodeByPath(filePath) {
  if (!filePath) return;
  const node = state.data.nodes.find(n => state._pathsMatch(state._getNodeFilePath(n), filePath));
  if (node) {
    state.ui.focusedNode = node;
    getRenderer().focusNode(node);
    updateVisuals();
  }
}

function focusNodeById(msg) {
  const nodeId = msg.nodeId || (msg.node && msg.node.id);
  const node = state.data.nodes.find(n => n.id === nodeId);

  if (!node) return;

  if (node.x === undefined || node.y === undefined) {
    setTimeout(() => focusNodeById(msg), 100);
    return;
  }

  state.ui.focusedNode = node;
  getRenderer().focusNode(node);
  updateVisuals();
}


// 2D GraphRenderer implementation

class GraphRenderer2D extends GraphRenderer {
  createLabelRenderer() {
    return {
      apply: (graph, getNodeProps) => {
        const getFontSize = () => this.state.controls.textSize || 12;
        const getLabel = (node, props) => props?.label || node.name || node.id;

        graph
          .nodeCanvasObject((node, ctx) => {
            const props = getNodeProps(node);
            if (!props) return;
            const label = getLabel(node, props);
            const fontSize = getFontSize();
            ctx.font = `${fontSize}px Sans-Serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = applyOpacityToColor('#ffffff', props.opacity);
            ctx.fillText(label, node.x, node.y);
          })
          .nodeCanvasObjectMode(() => 'after');
      },
      clear: (graph) => {
        graph.nodeCanvasObjectMode(() => null);
      }
    };
  }

  createGraph(container) {
    return ForceGraph()(container);
  }

  focusNode(node) {
    if (this.state.graph && node.x !== undefined && node.y !== undefined) {
      this.state.graph.centerAt(node.x, node.y, 1000);
    }
  }

  checkLibraryAvailability() {
    return typeof ForceGraph !== 'undefined';
  }

  getLibraryName() {
    return 'ForceGraph';
  }

  getModeName() {
    return '2D';
  }
}


// 3D GraphRenderer implementation

class GraphRenderer3D extends GraphRenderer {
  createLabelRenderer() {
    return {
      apply: (graph, getNodeProps) => {
        if (typeof window.CSS2DObject === 'undefined') {
          console.warn('[LabelRenderer] CSS2DObject not available');
          return;
        }

        const getFontSize = () => this.state.controls.nameFontSize || 12;
        const getLabel = (node, props) => props?.label || node.name || node.id;

        graph.nodeThreeObject(node => {
          const props = getNodeProps(node);
          const div = document.createElement('div');
          div.textContent = getLabel(node, props);

          // 透明度を色とopacityの両方で反映
          const opacity = props.opacity !== undefined ? props.opacity : 1;

          Object.assign(div.style, {
            fontSize: `${getFontSize()}px`,
            fontFamily: 'sans-serif',
            padding: '2px 4px',
            borderRadius: '2px',
            pointerEvents: 'none',
            color: props.color,
            opacity: opacity.toString()
          });
          const label = new window.CSS2DObject(div);
          label.position.set(0, -8, 0);
          return label;
        }).nodeThreeObjectExtend(true);
      },
      clear: (graph) => {
        graph.nodeThreeObject(null).nodeThreeObjectExtend(false);
      }
    };
  }

  createGraph(container) {
    // Setup CSS2DRenderer for labels if available
    let extraRenderers = [];
    if (typeof window.CSS2DRenderer !== 'undefined') {
      const renderer = new window.CSS2DRenderer();
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.domElement.style.position = 'absolute';
      renderer.domElement.style.top = '0';
      renderer.domElement.style.pointerEvents = 'none';
      container.appendChild(renderer.domElement);
      this.state.setLabelRenderer(renderer);
      extraRenderers = [renderer];
    }

    return ForceGraph3D({ extraRenderers })(container);
  }

  focusNode(node) {
    if (!this.state.graph || !node) return;

    if (node.x === undefined || node.y === undefined || node.z === undefined) {
      setTimeout(() => this.focusNode(node), 100);
      return;
    }

    const currentCameraPos = this.state.graph.cameraPosition();
    const oldNode = this.state.ui.focusedNode || { x: 0, y: 0, z: 0 };

    const cameraPos = {
      x: node.x + currentCameraPos.x - oldNode.x,
      y: node.y + currentCameraPos.y - oldNode.y,
      z: node.z + currentCameraPos.z - oldNode.z
    };

    this.state.graph.cameraPosition(cameraPos, node, DEBUG.AUTO_ROTATE_DELAY);
    setTimeout(() => this.updateAutoRotation(), DEBUG.AUTO_ROTATE_DELAY);
  }

  checkLibraryAvailability() {
    return typeof ForceGraph3D !== 'undefined';
  }

  getLibraryName() {
    return 'ForceGraph3D';
  }

  getModeName() {
    return '3D';
  }

  setupEventListeners(graph) {
    const controls = graph.controls();
    if (controls) {
      controls.addEventListener('start', () => {
        this.state.ui.isUserInteracting = true;
        this.cancelRotation();
        this.updateAutoRotation();
      });
      controls.addEventListener('end', () => {
        this.cancelRotation();
        this.state.rotation.timeout = setTimeout(() => {
          this.state.ui.isUserInteracting = false;
          this.updateAutoRotation();
        }, DEBUG.AUTO_ROTATE_DELAY);
      });
    }
  }

  onGraphUpdated() {
    this.updateAutoRotation();
  }

  cancelRotation() {
    if (this.state.rotation.frame) {
      cancelAnimationFrame(this.state.rotation.frame);
      this.state.rotation.frame = null;
    }
    clearTimeout(this.state.rotation.timeout);
  }

  updateAutoRotation() {
    this.cancelRotation();
    if (!this.state.graph) return;

    if (this.state.controls.autoRotate && !this.state.ui.isUserInteracting) {
      const pos = this.state.graph.cameraPosition();
      const controls = this.state.graph.controls();
      const target = controls ? controls.target : { x: 0, y: 0, z: 0 };

      this.state.rotation.startAngle = Math.atan2(pos.x - target.x, pos.z - target.z);
      this.state.rotation.startTime = Date.now();

      const rotate = () => {
        const camera = this.state.graph.camera();
        const controls = this.state.graph.controls();
        if (camera && controls) {
          if (this.state.ui.focusedNode) {
            controls.target.set(
              this.state.ui.focusedNode.x || 0,
              this.state.ui.focusedNode.y || 0,
              this.state.ui.focusedNode.z || 0
            );
          }
          const elapsed = (Date.now() - this.state.rotation.startTime) * 0.001;
          const angle = this.state.rotation.startAngle + elapsed * this.state.controls.rotateSpeed;
          const distance = Math.sqrt(
            (camera.position.x - controls.target.x) ** 2 +
            (camera.position.z - controls.target.z) ** 2
          );
          camera.position.x = controls.target.x + distance * Math.sin(angle);
          camera.position.z = controls.target.z + distance * Math.cos(angle);
          camera.lookAt(controls.target);
        }
        this.state.rotation.frame = requestAnimationFrame(rotate);
      };
      rotate();
    } else if (this.state.ui.focusedNode) {
      const keepFocus = () => {
        const controls = this.state.graph.controls();
        if (controls && this.state.ui.focusedNode) {
          controls.target.set(
            this.state.ui.focusedNode.x || 0,
            this.state.ui.focusedNode.y || 0,
            this.state.ui.focusedNode.z || 0
          );
        }
        this.state.rotation.frame = requestAnimationFrame(keepFocus);
      };
      keepFocus();
    }
  }
}


const messageHandlers = {
  data: msg => {
    state.updateData(msg.data);
    updateGraph({ reheatSimulation: true });
  },
  controls: msg => {
    state.updateControls(msg.controls);
    updateVisuals();
  },
  stackTrace: msg => {
    state.ui.stackTraceLinks = new Set(msg.paths.map(p => p.link));
    updateVisuals();
  },
  focusNode: msg => {
    const filePath = msg.filePath || (msg.node && msg.node.filePath);
    if (filePath) {
      focusNodeByPath(filePath);
    }
  },
  focusNodeById: msg => {
    focusNodeById(msg);
  },
  update: msg => {
    const hasDataChange = !!msg.data;
    const oldIs3DMode = state.controls.is3DMode;

    if (msg.data) {
      state.updateData(msg.data);
    }
    if (msg.controls) {
      state.updateControls(msg.controls);
    }
    if (msg.stackTracePaths) {
      state.ui.stackTraceLinks = new Set(msg.stackTracePaths.map(p => p.link));
    }

    const modeChanged = msg.controls && (state.controls.is3DMode !== oldIs3DMode);

    if (hasDataChange || modeChanged) {
      updateGraph({ reheatSimulation: true });
    } else {
      updateVisuals();
    }
  },
  toggle3DMode: msg => {
       state.toggleMode();
  }
};

if (vscode) {
  window.addEventListener('message', event => {
    const msg = event.data;
    const handler = messageHandlers[msg.type];
    if (handler) {
      handler(msg);
    } else {
      console.warn('[DependViz] Unknown message type:', msg.type);
    }
  });

  vscode.postMessage({ type: 'ready' });
}


window.addEventListener('resize', handleResize);

setTimeout(() => {
  if (state.initGraph()) {
    updateGraph();
  } else {
    console.error('[DependViz] Failed to initialize graph on startup');
  }
}, 100);

})(DEFAULT_CONTROLS, COLORS, DEBUG);
        }).catch(error => {
            console.error('[Template] Failed to load ForceGraph:', error);
            document.body.innerHTML = '<div style="color: red; padding: 20px;">Failed to load graph library: ' + error.message + '</div>';
        });
    </script>
</body>
</html>

